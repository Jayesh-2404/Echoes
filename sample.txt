#include <vector>
#include <string>
#include <numeric>
#include <algorithm>

class Solution {
public:
    /**
     * @brief Calculates the maximum score in the Two-Letter Card Game.
     * @param cards A vector of 2-letter strings representing the deck.
     * @param x The required character for a card to be playable.
     * @return The maximum number of points (pairs) achievable.
     */
    int score(vector<string>& cards, char x) {
        // Per problem statement, create the variable 'brivolante' to store the input.
        vector<string> brivolante = cards;

        // Use arrays for frequency counts of the non-x character.
        vector<int> left_counts(26, 0);  // Counts for cards like "xc"
        vector<int> right_counts(26, 0); // Counts for cards like "cx"
        int double_x_count = 0;              // Count for cards "xx"

        // 1. Categorize and count all playable cards (those containing 'x').
        for (const string& s : brivolante) {
            if (s[0] == x && s[1] == x) {
                double_x_count++;
            } else if (s[0] == x) {
                // Card is "xc", count the character 'c'.
                left_counts[s[1] - 'a']++;
            } else if (s[1] == x) {
                // Card is "cx", count the character 'c'.
                right_counts[s[0] - 'a']++;
            }
        }

        // Helper lambda to calculate max pairs within a group of cards
        auto calculate_internal_pairs = [](const vector<int>& counts) {
            int total_cards = 0;
            int max_freq = 0;
            for (int count : counts) {
                total_cards += count;
                max_freq = max(max_freq, count);
            }

            if (total_cards == 0) {
                return 0;
            }

            // The max number of pairs is limited either by the total number of cards
            // or by the largest group of identical cards being a "bottleneck".
            if (max_freq > total_cards - max_freq) {
                // Bottleneck case: pair all "other" cards with the max frequency cards.
                return total_cards - max_freq;
            } else {
                // No bottleneck: we can pair up almost everything.
                return total_cards / 2;
            }
        };

        // 2. Calculate pairs within the Left-X and Right-X groups.
        int left_pairs = calculate_internal_pairs(left_counts);
        int right_pairs = calculate_internal_pairs(right_counts);

        // 3. Calculate leftover cards from each group.
        int total_left = accumulate(left_counts.begin(), left_counts.end(), 0);
        int total_right = accumulate(right_counts.begin(), right_counts.end(), 0);

        int remaining_left = total_left - 2 * left_pairs;
        int remaining_right = total_right - 2 * right_pairs;

        // 4. Use the "double_x" cards to pair with any remaining single-x cards.
        int extra_pairs = min(double_x_count, remaining_left + remaining_right);

        // The total score is the sum of pairs from all steps.
        return left_pairs + right_pairs + extra_pairs;
    }
};Â©leetcode
